use super::Expr;

pub program -> Vec<Expr>
  = commands:(command*) { commands }

command -> Expr
  = c:add { c }
  / c:sub { c }
  / c:out { c }
  / c:in { c}
  / c:clear { c }
  / c:right { c }
  / c:left { c }
  / c:scan_right { c }
  / c:scan_left { c }
  / "[" commands:command* "]" { Expr::Loop(commands) }

right -> Expr
  = commands:">"+ { Expr::Right(commands.len()) }

left -> Expr
  = commands:"<"+ { Expr::Left(commands.len()) }

add -> Expr
  = ">" c:add "<" { match c { Expr::Add(count, offset) => Expr::Add(count, offset + 1), _ => panic!("parse failed") } }
  / commands:"+"+ { Expr::Add(commands.len() as u8, 0) }

sub -> Expr
  = ">" c:sub "<" { match c { Expr::Sub(count, offset) => Expr::Sub(count, offset + 1), _ => panic!("parse failed") } }
  / commands:"-"+ { Expr::Sub(commands.len() as u8, 0) }

clear -> Expr
  = ">" c:clear "<" { match c { Expr::Clear(offset) => Expr::Clear(offset + 1), _ => panic!("parse failed") } }
  / "[-]" { Expr::Clear(0) }
  / "[+]" { Expr::Clear(0) }

out -> Expr
  = ">" c:out "<" { match c { Expr::Out(offset) => Expr::Out(offset + 1), _ => panic!("parse failed") } }
  / "." { Expr::Out(0) }

in -> Expr
  = ">" c:in "<" { match c { Expr::In(offset) => Expr::In(offset + 1), _ => panic!("parse failed") } }
  / "," { Expr::In(0) }

scan_right -> Expr
  = "[>]" { Expr::ScanRight }

scan_left -> Expr
  = "[>]" { Expr::ScanLeft }
